runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library(utils)
library(stats)
library(utils)
library(datasets)
library(graphics)
library(shiny)
library(grDevices)
library(methods)
library(leaflet)
library(dplyr)
library(shinycssloaders)
library(rgdal)
library(plotly)
library(htmltools)
library(DT)
library(shinyjs)
library(shinythemes)
library(rsconnect)
library(crosstalk)
data <- read.csv(file = 'DataInventory.csv')
# Wrap data frame in SharedData
sd <- SharedData$new(quakes[sample(nrow(quakes), 100),])
# Create a filter input
filter_slider("mag", "Magnitude", sd, column=~mag, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
# Wrap data frame in SharedData
sd <-data
# Create a filter input
filter_slider("asl", "Age Data:", sd, column=~asl, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
# Wrap data frame in SharedData
sd <- SharedData$new(quakes[sample(nrow(quakes), 100),])
# Create a filter input
filter_slider("mag", "Magnitude", sd, column=~mag, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
quakes
SharedData$new
# Wrap data frame in SharedData
sd <-SharedData$new(data[sample(nrow(data), 100),])
# Create a filter input
filter_slider("asl", "Age Data:", sd, column=~asl, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
# Wrap data frame in SharedData
sd <-SharedData$new(data)
# Create a filter input
filter_slider("asl", "Age Data:", sd, column=~asl, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
# Wrap data frame in SharedData
sd <-SharedData$new(data)
# Create a filter input
filter_slider("asl", "Age Data:", sd, column=~asl, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
# Wrap data frame in SharedData
sd <- SharedData$new(quakes[sample(nrow(quakes), 100),])
# Create a filter input
filter_slider("mag", "Magnitude", sd, column=~mag, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
library(utils)
library(stats)
library(utils)
library(datasets)
library(graphics)
library(shiny)
library(grDevices)
library(methods)
library(leaflet)
library(dplyr)
library(shinycssloaders)
library(rgdal)
library(plotly)
library(htmltools)
library(DT)
library(shinyjs)
library(shinythemes)
library(rsconnect)
library(crosstalk)
library(htmlwidgets)
data <- read.csv(file = 'DataInventory.csv')
# Wrap data frame in SharedData
sd <- SharedData$new(quakes[sample(nrow(quakes), 100),])
# Create a filter input
filter_slider("mag", "Magnitude", sd, column=~mag, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
runApp()
# Wrap data frame in SharedData
sd <- SharedData$new(quakes[sample(nrow(quakes), 100),])
# Create a filter input
filter_slider("mag", "Magnitude", sd, column=~mag, step=0.1, width=250)
# Use SharedData like a dataframe with Crosstalk-enabled widgets
bscols(
leaflet(sd) %>% addTiles() %>% addMarkers(),
datatable(sd, extensions="Scroller", style="bootstrap", class="compact", width="100%",
options=list(deferRender=TRUE, scrollY=300, scroller=TRUE))
)
quakes
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::shinyApp(
ui = fluidPage(
column(
width = 3,
br(),
actionButton(
"select_all_rows_button",
"Select All Table Rows"
),
br(),
actionButton(
"clear_rows_button",
"Clear Table Selections"
)
),
column(
width = 9,
fluidRow(
column(
width = 12,
solidHeader = TRUE,
leafletOutput(
"my_leaflet"
)
)
),
fluidRow(
column(
width = 12,
solidHeader = TRUE,
DTOutput(
"my_datatable"
)
)
)
)
),
server = function(session, input, output) {
quakes_r <- reactive({ as_tibble(quakes) })
output$my_datatable <- renderDT({
quakes_r() %>%
datatable()
})
# base map that we will add points to with leafletProxy()
output$my_leaflet <- renderLeaflet({
leaflet() %>%
addProviderTiles(
provider = providers$CartoDB.Positron,
options = providerTileOptions(
noWrap = FALSE
)
) %>%
setView(
lat = -25.5,
lng = 178.58,
zoom = 4
)
})
observeEvent(input$my_datatable_rows_selected, {
selected_lats <- eventReactive(input$my_datatable_rows_selected, {
as.list(quakes_r()$lat[c(unique(input$my_datatable_rows_selected))])
})
selected_longs <- eventReactive(input$my_datatable_rows_selected, {
as.list(quakes_r()$long[c(unique(input$my_datatable_rows_selected))])
})
selected_depths <- eventReactive(input$my_datatable_rows_selected, {
as.list(quakes_r()$depth[c(unique(input$my_datatable_rows_selected))])
})
selected_mags <- eventReactive(input$my_datatable_rows_selected, {
as.list(quakes_r()$mag[c(unique(input$my_datatable_rows_selected))])
})
selected_stations <- eventReactive(input$my_datatable_rows_selected, {
as.list(quakes_r()$stations[c(unique(input$my_datatable_rows_selected))])
})
# this is the data that will be passed to the leaflet in the addCircleMarkers argument,
# as well as the popups when the points are hovered over
map_df <- reactive({
tibble(lat = unlist(selected_lats()),
lng = unlist(selected_longs()),
depth = unlist(selected_depths()),
mag = unlist(selected_mags()),
stations = unlist(selected_stations()))
})
leafletProxy("my_leaflet", session) %>%
clearMarkers() %>%
addCircleMarkers(
data = map_df(),
lng = ~lng,
lat = ~lat,
fillColor = "blue",
stroke = TRUE,
color = "white",
radius = 3,
weight = 1,
fillOpacity = 0.4,
popup = paste0("lat: ", map_df()$lat, "<br>",
"lng: ", map_df()$lng, "<br>",
"depth: ", map_df()$depth, "<br>",
"mag: ", map_df()$mag, "<br>",
"stations: ", map_df()$stations)
)
})
# create a proxy to modify datatable without recreating it completely
DT_proxy <- dataTableProxy("my_datatable")
# clear row selections when clear_rows_button is clicked
observeEvent(input$clear_rows_button, {
selectRows(DT_proxy, NULL)
})
# clear markers from leaflet when clear_rows_button is clicked
observeEvent(input$clear_rows_button, {
clearMarkers(leafletProxy("my_leaflet", session))
})
# select all rows when select_all_rows_button is clicked
observeEvent(input$select_all_rows_button, {
selectRows(DT_proxy, input$my_datatable_rows_all)
})
}
)
leafletProxy("my_leaflet", session) %>%
clearMarkers() %>%
addCircleMarkers(
data = map_df(),
lng = ~lng,
lat = ~lat,
fillColor = "blue",
stroke = TRUE,
color = "white",
radius = 3,
weight = 1,
fillOpacity = 0.4,
popup = paste0("lat: ", map_df()$lat, "<br>",
"lng: ", map_df()$lng, "<br>",
"depth: ", map_df()$productivity_index, "<br>",
"mag: ", map_df()$productivity, "<br>",
"stations: ", map_df()$asl)
)
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp('Untitled.R')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
data <- read.csv(file = 'DataInventory.csv')
runApp()
data <- read.csv(file = 'DataInventory.csv')
runApp()
runApp()
data <- read.csv(file = 'DataInventory.csv')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
data <- read.csv(file = 'DataInventory.csv')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
data %>% filter(Aerial == "Yes" & Weir == "Yes")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
data <- read.csv(file = 'DataInventory.csv')
runApp()
runApp()
runApp()
runApp()
runApp()
data <- read.csv(file = 'DataInventory.csv')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
colnames(data)
runApp()
runApp()
runApp()
runApp()
pal<- palette("red", "green", "blue", "purple")
runApp()
#this initiates and event that allows selected rows in the data table to pop up on the map, using the "clear all"
#and 'select all" action button initiated in the ui
beatCol <- colorFactor(palette = 'RdYlGn', data$region)
beatCol
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
expression(paste('Lake (# residence ',km^{-1}),')')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
